{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Computa\u00e7\u00e3o em Nuvem","text":"Edi\u00e7\u00e3o <p>2025.1</p>"},{"location":"#kit-c","title":"KIT-C","text":"<p>Mariana Albuquerque</p> <p>Lucas Novais</p>"},{"location":"#entregas","title":"Entregas","text":"<ul> <li> Roteiro 1 - Data 23/02/2025</li> <li> Roteiro 2 - </li> <li> Roteiro 3 -</li> <li> Roteiro 4 - </li> <li> Projeto</li> </ul>"},{"location":"#referencias","title":"Refer\u00eancias","text":"<p>Material for MkDocs</p>"},{"location":"roteiro1/main/","title":"Relat\u00f3rio Roteiro 1 de Computa\u00e7\u00e3o em Nuvem","text":"<p>Autores: Lucas Novais, Mariana Albuquerque</p>"},{"location":"roteiro1/main/#1-objetivo","title":"1. Objetivo","text":"<p>O roteiro tem como objetivo aprender os conceitos b\u00e1sicos sobre redes, subredes e o hardware que comp\u00f5em essas entidades. Ademais, o aprendizado sobre a manipula\u00e7\u00e3o de plataformas de gerenciamento desse hardware.</p> <p>Hardware (Bare Metal):</p> <ul> <li>1 NUC (main) com 10Gb e 1 SSD (120Gb)  </li> <li>1 NUC (server1) com 12Gb e 1 SSD (120Gb)  </li> <li>1 NUC (server2) com 16Gb e 2 SSD (120Gb + 120Gb)  </li> <li>3 NUCs (server3, server4 e server5) com 32Gb e 2 SSD (120Gb + 120Gb)  </li> <li>1 Switch DLink DSG-1210-28 de 28 portas  </li> <li>1 Roteador TP-Link TL-R470T+</li> </ul>"},{"location":"roteiro1/main/#2-infraestrutura","title":"2. Infraestrutura","text":"<p>Para operarmos em uma rede privada, foi necess\u00e1rio configurar o switch, o roteador e os NUCs, para que todos conversassem na mesma rede atrav\u00e9s do IP <code>172.16.0.X</code>.</p> <p>Al\u00e9m da modifica\u00e7\u00e3o dos IPs, fizemos um NAT para permitir o acesso remoto quando estiv\u00e9ssemos logados na rede do Insper.</p>"},{"location":"roteiro1/main/#3-app","title":"3. App","text":"<p>Ap\u00f3s a configura\u00e7\u00e3o da infraestrutura, foi instalado o PostgreSQL no <code>server1</code>, que serve como nosso banco de dados.</p> <p></p> <p>Verificamos a conex\u00e3o com sucesso \u2014 o status est\u00e1 como \u201cAtivo\u201d, acess\u00edvel a partir da m\u00e1quina MAIN. O servi\u00e7o est\u00e1 rodando na porta configurada pelo PostgreSQL.</p> <p></p> <p>Foi verificado que o banco de dados est\u00e1 conectado a porta <code>5432</code>, que \u00e9 a porta padr\u00e3o do PostgreSQL. </p>"},{"location":"roteiro1/main/#31-acesso-ao-maas","title":"3.1 Acesso ao MAAS","text":"<p>A partir da m\u00e1quina em que foi implantado, acessamos o dashboard do MAAS.</p> <p></p>"},{"location":"roteiro1/main/#311-aba-de-imagens","title":"3.1.1 Aba de Imagens","text":""},{"location":"roteiro1/main/#312-testes-e-commissioning","title":"3.1.2 Testes e Commissioning","text":""},{"location":"roteiro1/main/#server1","title":"Server1","text":""},{"location":"roteiro1/main/#server2","title":"Server2","text":""},{"location":"roteiro1/main/#server3","title":"Server3","text":""},{"location":"roteiro1/main/#server4","title":"Server4","text":""},{"location":"roteiro1/main/#server5","title":"Server5","text":""},{"location":"roteiro1/main/#dashboard-do-maas-com-as-duas-maquinas-e-seus-respecitivos-ips","title":"Dashboard do MAAS com as duas m\u00e1quinas e seus respecitivos IPs","text":""},{"location":"roteiro1/main/#32-aplicacao-django","title":"3.2 Aplica\u00e7\u00e3o Django","text":""},{"location":"roteiro1/main/#321-print-da-aplicacao-conectada-ao-server","title":"3.2.1 Print da aplica\u00e7\u00e3o conectada ao server","text":""},{"location":"roteiro1/main/#322-configuracao-manual-do-postgresql","title":"3.2.2 Configura\u00e7\u00e3o manual do PostgreSQL","text":"<p>Instalamos o <code>postgres</code> no <code>server1</code>, criamos um usu\u00e1rio e um banco para a aplica\u00e7\u00e3o. Editamos as configura\u00e7\u00f5es do <code>postgresql.conf</code> para permitir conex\u00f5es remotas e adicionamos uma linha em <code>pg_hba.conf</code> para permitir acessos da subnet por qualquer m\u00e1quina.</p>"},{"location":"roteiro1/main/#323-deploy-do-django-no-server2","title":"3.2.3 Deploy do Django no Server2","text":"<p>Realizamos o login pelo terminal via MAAS, requisitamos o <code>server2</code>, fizemos o deploy e clonagem do reposit\u00f3rio. Ap\u00f3s reboot, foi criado um t\u00fanel SSH \u2014 dispensando a necessidade de NAT.</p>"},{"location":"roteiro1/main/#324-expansao-para-multiplos-servidores","title":"3.2.4 Expans\u00e3o para m\u00faltiplos servidores","text":""},{"location":"roteiro1/main/#maas-com-3-maquinas","title":"MAAS com 3 m\u00e1quinas","text":""},{"location":"roteiro1/main/#django-no-server2","title":"Django no Server2","text":""},{"location":"roteiro1/main/#django-no-server3","title":"Django no Server3","text":""},{"location":"roteiro1/main/#33-comparacao-manual-vs-ansible","title":"3.3 Compara\u00e7\u00e3o: Manual vs Ansible","text":"<p>O Ansible \u00e9 mais recomendado para cen\u00e1rios com m\u00faltiplos servidores por sua escalabilidade, consist\u00eancia e velocidade de configura\u00e7\u00e3o.</p>"},{"location":"roteiro1/main/#maas-com-4-maquinas","title":"MAAS com 4 m\u00e1quinas","text":""},{"location":"roteiro1/main/#34-load-balancing-com-nginx","title":"3.4 Load Balancing com Nginx","text":""},{"location":"roteiro1/main/#reverse-proxy-no-server4","title":"Reverse Proxy no Server4","text":"<p>Criamos um proxy reverso com o <code>Nginx</code> no <code>server4</code>, que encaminha requisi\u00e7\u00f5es alternadamente para os <code>server2</code> e <code>server3</code>.</p>"},{"location":"roteiro1/main/#testes-com-get-request","title":"Testes com <code>GET</code> Request:","text":"<ul> <li> <p>T\u00fanel para o server4 batendo no server2 </p> </li> <li> <p>T\u00fanel para o server4 batendo no server3 </p> </li> </ul>"},{"location":"roteiro1/main/#referencias","title":"Refer\u00eancias","text":"<ul> <li>Dashboard MAAS</li> <li>PostgreSQL</li> <li>Django + SSH Tunneling</li> <li>Nginx como Load Balancer</li> </ul>"},{"location":"roteiro2/main/","title":"Roteiro 2","text":""},{"location":"roteiro2/main/#objetivo","title":"Objetivo","text":""},{"location":"roteiro3/main/","title":"Relat\u00f3rio Roteiro 3 de Computa\u00e7\u00e3o em Nuvem","text":"<p>Autores: Lucas Novais, Mariana Albuquerque</p>"},{"location":"roteiro3/main/#1-objetivo","title":"1. Objetivo","text":"<p>O roteiro tem como objetivo entender os conceitos b\u00e1sicos de private cloud, bem como aprofundar conceitos sobre redes virtuais, sub-redes e o hardware que comp\u00f5em essas entidades. Ademais, o aprendizado sobre a manipula\u00e7\u00e3o de plataformas de gerenciamento desse hardware.</p>"},{"location":"roteiro3/main/#2-infraestrutura","title":"2. Infraestrutura","text":"<p>Para criarmos a infraestrutura necess\u00e1ria para este roteiro, precisamos implantar o Openstack, que \u00e9 uma plataforma de computa\u00e7\u00e3o em nuvem de c\u00f3digo aberto. O OpenStack permite a cria\u00e7\u00e3o e o gerenciamento de recursos de computa\u00e7\u00e3o, armazenamento e rede em ambientes de nuvem privada.</p>"},{"location":"roteiro3/main/#3-setup-do-openstack","title":"3. Setup do OpenStack","text":"<p>Nesta etapa, configuramos os servi\u00e7os que controlam as VMs, como o Nova, o Neutron, que gerencia a rede, o Cinder, que cuida do armazenamento, al\u00e9m de configurar o Horizon, que \u00e9 o painel de controle do OpenStack.</p>"},{"location":"roteiro3/main/#31-tarefa-1","title":"3.1 Tarefa 1","text":"<p>A) Verificar o status do Juju</p> <p></p> <p>B) Dashboard MAAS </p> <p>C) Aba compute overview no OpenStack </p> <p>D) Aba compute instances no OpenStack </p> <p>E) Aba network topology no OpenStack </p>"},{"location":"roteiro3/main/#32-tarefa-2","title":"3.2 Tarefa 2","text":"<ol> <li> <p>A. Dashboard do MAAS com as m\u00e1quinas </p> <p>B. Aba compute overview no OpenStack </p> <p>C. Aba compute instances no OpenStack </p> <p>D. Aba network topology no OpenStack </p> </li> <li> <p>Enumere as diferen\u00e7as encontradas entre os prints das telas na Tarefa 1 e na Tarefa 2.</p> </li> <li> <p>Explique como cada recurso foi criado.</p> </li> </ol>"},{"location":"roteiro3/main/#33-tarefa-3","title":"3.3 Tarefa 3","text":"<p>Arquitetura de rede </p>"},{"location":"roteiro3/main/#34-tarefa-4","title":"3.4 Tarefa 4","text":"<ol> <li>Escreva um relat\u00f3rio dos passos utilizados. (Coloque em uma se\u00e7\u00e3o do material a ser entregue do roteiro - MkDocs!!!!!!!)</li> </ol> <p>Primeiramente, para levantar duas inst\u00e2ncias com a API do FastAPI, foi necess\u00e1rio criar uma rede virtual no OpenStack. Em seguida, foram criadas duas inst\u00e2ncias de m\u00e1quinas virtuais (VMs) com o Ubuntu Server 22.04, que serviram como servidores para a aplica\u00e7\u00e3o FastAPI. Essas VMs foram conectadas \u00e0 rede virtual criada anteriormente. Publicamos uma imagem do FastAPI no Docker Hub, e depois, instalamos o Docker nas VMs. Com o Docker instalado, baixamos a imagem do FastAPI e executamos os containers.</p> <p>Para o banco de dados, utilizamos o PostgreSQL, que foi instalado em uma das VMs. Configuramos o banco de dados para aceitar conex\u00f5es da rede virtual e criamos as tabelas necess\u00e1rias para a aplica\u00e7\u00e3o.</p> <p>Por fim, configuramos um balanceador de carga (Nginx) para distribuir as requisi\u00e7\u00f5es entre as duas inst\u00e2ncias do FastAPI. O Nginx foi instalado em uma VM separada, que tamb\u00e9m estava conectada \u00e0 rede virtual. Essa VM atuou como um ponto de entrada para as requisi\u00e7\u00f5es, encaminhando-as para as inst\u00e2ncias do FastAPI.</p> <ol> <li>Anexe fotos e/ou diagramas contendo: arquitetura de rede da sua infraestrutura dentro do Dashboard do Openstack</li> <li>Lista de VMs utilizadas com nome e IPs alocados, Print do Dashboard do FastAPI conectado via m\u00e1quina Nginx/LB.</li> <li>Prints, cada um demonstrando em qual server (m\u00e1quina fisica) cada inst\u00e2ncia foi alocado pelo OpenStack.</li> </ol>"}]}