{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Computa\u00e7\u00e3o em Nuvem","text":"Edi\u00e7\u00e3o <p>2025.1</p>"},{"location":"#kit-c","title":"KIT-C","text":"<p>Mariana Albuquerque</p> <p>Lucas Novais</p>"},{"location":"#entregas","title":"Entregas","text":"<ul> <li> Roteiro 1 - Data 23/02/2025</li> <li> Roteiro 2 - </li> <li> Roteiro 3 -</li> <li> Roteiro 4 - </li> <li> Projeto</li> </ul>"},{"location":"#referencias","title":"Refer\u00eancias","text":"<p>Material for MkDocs</p>"},{"location":"roteiro1/main/","title":"Relat\u00f3rio Roteiro 1 de Computa\u00e7\u00e3o em Nuvem","text":"<p>Autores: Lucas Novais, Mariana Albuquerque</p>"},{"location":"roteiro1/main/#1-objetivo","title":"1. Objetivo","text":"<p>O roteiro tem como objetivo aprender os conceitos b\u00e1sicos sobre redes, subredes e o hardware que comp\u00f5em essas entidades. Ademais, o aprendizado sobre a manipula\u00e7\u00e3o de plataformas de gerenciamento desse hardware.</p> <p>Hardware (Bare Metal):</p> <ul> <li>1 NUC (main) com 10Gb e 1 SSD (120Gb)  </li> <li>1 NUC (server1) com 12Gb e 1 SSD (120Gb)  </li> <li>1 NUC (server2) com 16Gb e 2 SSD (120Gb + 120Gb)  </li> <li>3 NUCs (server3, server4 e server5) com 32Gb e 2 SSD (120Gb + 120Gb)  </li> <li>1 Switch DLink DSG-1210-28 de 28 portas  </li> <li>1 Roteador TP-Link TL-R470T+</li> </ul>"},{"location":"roteiro1/main/#2-infraestrutura","title":"2. Infraestrutura","text":"<p>Para operarmos em uma rede privada, foi necess\u00e1rio configurar o switch, o roteador e os NUCs, para que todos conversassem na mesma rede atrav\u00e9s do IP <code>172.16.0.X</code>.</p> <p>Al\u00e9m da modifica\u00e7\u00e3o dos IPs, fizemos um NAT para permitir o acesso remoto quando estiv\u00e9ssemos logados na rede do Insper.</p>"},{"location":"roteiro1/main/#3-app","title":"3. App","text":"<p>Ap\u00f3s a configura\u00e7\u00e3o da infraestrutura, foi instalado o PostgreSQL no <code>server1</code>, que serve como nosso banco de dados.</p> <p></p> <p>Verificamos a conex\u00e3o com sucesso \u2014 o status est\u00e1 como \u201cAtivo\u201d, acess\u00edvel a partir da m\u00e1quina MAIN. O servi\u00e7o est\u00e1 rodando na porta configurada pelo PostgreSQL.</p> <p></p> <p>Foi verificado que o banco de dados est\u00e1 conectado a porta <code>5432</code>, que \u00e9 a porta padr\u00e3o do PostgreSQL. </p>"},{"location":"roteiro1/main/#31-acesso-ao-maas","title":"3.1 Acesso ao MAAS","text":"<p>A partir da m\u00e1quina em que foi implantado, acessamos o dashboard do MAAS.</p> <p></p>"},{"location":"roteiro1/main/#311-aba-de-imagens","title":"3.1.1 Aba de Imagens","text":""},{"location":"roteiro1/main/#312-testes-e-commissioning","title":"3.1.2 Testes e Commissioning","text":""},{"location":"roteiro1/main/#server1","title":"Server1","text":""},{"location":"roteiro1/main/#server2","title":"Server2","text":""},{"location":"roteiro1/main/#server3","title":"Server3","text":""},{"location":"roteiro1/main/#server4","title":"Server4","text":""},{"location":"roteiro1/main/#server5","title":"Server5","text":""},{"location":"roteiro1/main/#dashboard-do-maas-com-as-duas-maquinas-e-seus-respecitivos-ips","title":"Dashboard do MAAS com as duas m\u00e1quinas e seus respecitivos IPs","text":""},{"location":"roteiro1/main/#32-aplicacao-django","title":"3.2 Aplica\u00e7\u00e3o Django","text":""},{"location":"roteiro1/main/#321-print-da-aplicacao-conectada-ao-server","title":"3.2.1 Print da aplica\u00e7\u00e3o conectada ao server","text":""},{"location":"roteiro1/main/#322-configuracao-manual-do-postgresql","title":"3.2.2 Configura\u00e7\u00e3o manual do PostgreSQL","text":"<p>Instalamos o <code>postgres</code> no <code>server1</code>, criamos um usu\u00e1rio e um banco para a aplica\u00e7\u00e3o. Editamos as configura\u00e7\u00f5es do <code>postgresql.conf</code> para permitir conex\u00f5es remotas e adicionamos uma linha em <code>pg_hba.conf</code> para permitir acessos da subnet por qualquer m\u00e1quina.</p>"},{"location":"roteiro1/main/#323-deploy-do-django-no-server2","title":"3.2.3 Deploy do Django no Server2","text":"<p>Realizamos o login pelo terminal via MAAS, requisitamos o <code>server2</code>, fizemos o deploy e clonagem do reposit\u00f3rio. Ap\u00f3s reboot, foi criado um t\u00fanel SSH \u2014 dispensando a necessidade de NAT.</p>"},{"location":"roteiro1/main/#324-expansao-para-multiplos-servidores","title":"3.2.4 Expans\u00e3o para m\u00faltiplos servidores","text":""},{"location":"roteiro1/main/#maas-com-3-maquinas","title":"MAAS com 3 m\u00e1quinas","text":""},{"location":"roteiro1/main/#django-no-server2","title":"Django no Server2","text":""},{"location":"roteiro1/main/#django-no-server3","title":"Django no Server3","text":""},{"location":"roteiro1/main/#33-comparacao-manual-vs-ansible","title":"3.3 Compara\u00e7\u00e3o: Manual vs Ansible","text":"<p>O Ansible \u00e9 mais recomendado para cen\u00e1rios com m\u00faltiplos servidores por sua escalabilidade, consist\u00eancia e velocidade de configura\u00e7\u00e3o.</p>"},{"location":"roteiro1/main/#maas-com-4-maquinas","title":"MAAS com 4 m\u00e1quinas","text":""},{"location":"roteiro1/main/#34-load-balancing-com-nginx","title":"3.4 Load Balancing com Nginx","text":""},{"location":"roteiro1/main/#reverse-proxy-no-server4","title":"Reverse Proxy no Server4","text":"<p>Criamos um proxy reverso com o <code>Nginx</code> no <code>server4</code>, que encaminha requisi\u00e7\u00f5es alternadamente para os <code>server2</code> e <code>server3</code>.</p>"},{"location":"roteiro1/main/#testes-com-get-request","title":"Testes com <code>GET</code> Request:","text":"<ul> <li> <p>T\u00fanel para o server4 batendo no server2 </p> </li> <li> <p>T\u00fanel para o server4 batendo no server3 </p> </li> </ul>"},{"location":"roteiro1/main/#referencias","title":"Refer\u00eancias","text":"<ul> <li>Dashboard MAAS</li> <li>PostgreSQL</li> <li>Django + SSH Tunneling</li> <li>Nginx como Load Balancer</li> </ul>"},{"location":"roteiro2/main/","title":"Relat\u00f3rio Roteiro 2 de Computa\u00e7\u00e3o em Nuvem","text":"<p>Autores: Lucas Novais, Mariana Albuquerque</p>"},{"location":"roteiro2/main/#1-objetivo","title":"1. Objetivo","text":"<p>O roteiro tem como objetivo ensinar, na pr\u00e1tica, como orquestrar o deploy de aplica\u00e7\u00f5es em uma infraestrutura bare metal usando o Juju junto com o MAAS. A ideia \u00e9 mostrar como conectar essas ferramentas, criar um controlador e fazer o deploy de aplica\u00e7\u00f5es reais, como o Grafana e o Prometheus.</p> <p>Hardware utilizado (Bare Metal):</p> <ul> <li>1 NUC (main) com 10\u202fGB RAM e 1 SSD (120\u202fGB)  </li> <li>1 NUC (server1) com 12\u202fGB RAM e 1 SSD (120\u202fGB)  </li> <li>1 NUC (server2) com 16\u202fGB RAM e 2 SSD (120\u202fGB + 120\u202fGB)  </li> <li>1 NUC (server3) com 32\u202fGB RAM e 2 SSD (120\u202fGB + 120\u202fGB)  </li> <li>1 Switch DLink DSG-1210-28 (28 portas)  </li> <li>1 Roteador TP-Link TL-R470T+</li> </ul>"},{"location":"roteiro2/main/#2-infraestrutura","title":"2. Infraestrutura","text":"<p>Essa etapa do roteiro ensina como preparar a infraestrutura para o Juju usar o MAAS como provedor de m\u00e1quinas.</p> <ol> <li>Garantimos que as m\u00e1quinas estejam no estado \u201cReady\u201d no MAAS.  </li> <li>Instalamos o Juju no servidor principal com <code>snap</code>.  </li> <li>Criamos o <code>maas-creds.yaml</code> com a API Key do MAAS, permitindo a comunica\u00e7\u00e3o entre o Juju e o MAAS.  </li> <li>Inicializamos o controlador com <code>juju bootstrap</code>, escolhendo a m\u00e1quina <code>server1</code>.</li> </ol>"},{"location":"roteiro2/main/#3-deploy-de-aplicacoes","title":"3. Deploy de Aplica\u00e7\u00f5es","text":"<p>Ap\u00f3s preparar a infraestrutura:</p> <ol> <li>Instalamos o Dashboard do Juju no controlador para acompanhar visualmente os deploys.</li> <li>Garantimos o modelo correto com <code>juju models</code> e <code>juju switch</code>.</li> <li>Baixamos os charms do Grafana e Prometheus com <code>juju download</code>.</li> <li>Fizemos o deploy com:    ```bash    juju deploy ./prometheus2_XXX.charm    juju deploy ./grafana_XXX.charm</li> </ol>"},{"location":"roteiro2/main/#4-tarefa","title":"4. Tarefa","text":"<p>MAAS Dashboard com as m\u00e1quinas:</p> <p></p> <p>juju status com Grafana ativo:</p> <p></p> <p>Dashboard Grafana com Prometheus:</p> <p></p> <p>Acessando dashboard pela rede do Insper:</p> <p></p> <p>Aplica\u00e7\u00f5es ativas no Juju:</p> <p></p>"},{"location":"roteiro3/main/","title":"Relat\u00f3rio Roteiro 3 de Computa\u00e7\u00e3o em Nuvem","text":"<p>Autores: Lucas Novais, Mariana Albuquerque</p>"},{"location":"roteiro3/main/#1-objetivo","title":"1. Objetivo","text":"<p>O roteiro tem como objetivo entender os conceitos b\u00e1sicos de private cloud, bem como aprofundar conceitos sobre redes virtuais, sub-redes e o hardware que comp\u00f5em essas entidades. Ademais, o aprendizado sobre a manipula\u00e7\u00e3o de plataformas de gerenciamento desse hardware.</p>"},{"location":"roteiro3/main/#2-infraestrutura","title":"2. Infraestrutura","text":"<p>Para criarmos a infraestrutura necess\u00e1ria para este roteiro, precisamos implantar o Openstack, que \u00e9 uma plataforma de computa\u00e7\u00e3o em nuvem de c\u00f3digo aberto. O OpenStack permite a cria\u00e7\u00e3o e o gerenciamento de recursos de computa\u00e7\u00e3o, armazenamento e rede em ambientes de nuvem privada.</p>"},{"location":"roteiro3/main/#3-setup-do-openstack","title":"3. Setup do OpenStack","text":"<p>Nesta etapa, configuramos os servi\u00e7os que controlam as VMs, como o Nova, o Neutron, que gerencia a rede, o Cinder, que cuida do armazenamento, al\u00e9m de configurar o Horizon, que \u00e9 o painel de controle do OpenStack.</p>"},{"location":"roteiro3/main/#31-tarefa-1","title":"3.1 Tarefa 1","text":"<p>A) Verificar o status do Juju </p> <p>B) Dashboard MAAS </p> <p>C) Aba compute overview no OpenStack </p> <p>D) Aba compute instances no OpenStack </p> <p>E) Aba network topology no OpenStack </p>"},{"location":"roteiro3/main/#32-tarefa-2","title":"3.2 Tarefa 2","text":"<p>A. Dashboard do MAAS com as m\u00e1quinas </p> <p>B. Aba compute overview no OpenStack </p> <p>C. Aba compute instances no OpenStack </p> <p>D. Aba network topology no OpenStack </p> <ol> <li> <p>Enumere as diferen\u00e7as encontradas entre os prints das telas na Tarefa 1 e na Tarefa 2. Antes n\u00e3o havia nenhuma inst\u00e2ncia criada e agora temos uma instancia criada no OpenStack, al\u00e9m de uma rede virtual configurada. O dashboard do MAAS agora mostra as m\u00e1quinas dispon\u00edveis, e a aba de compute overview no OpenStack exibe informa\u00e7\u00f5es sobre as inst\u00e2ncias criadas. A aba de compute instances agora mostra a inst\u00e2ncia criada, e a aba de network topology exibe a rede virtual configurada.</p> </li> <li> <p>Explique como cada recurso foi criado. Para criar a inst\u00e2ncia, foi configurado pelo Horizon, o painel de controle do OpenStack. Foi necess\u00e1rio selecionar a imagem do Ubuntu Server 22.04, escolher o tipo de inst\u00e2ncia, alocar os recursos necess\u00e1rios (CPU, mem\u00f3ria e disco) e associar a inst\u00e2ncia \u00e0 rede virtual criada anteriormente. Ap\u00f3s isso, a inst\u00e2ncia foi lan\u00e7ada e ficou dispon\u00edvel para uso.</p> </li> </ol>"},{"location":"roteiro3/main/#33-tarefa-3","title":"3.3 Tarefa 3","text":"<p>Arquitetura de rede </p>"},{"location":"roteiro3/main/#34-tarefa-4","title":"3.4 Tarefa 4","text":"<ol> <li>Escreva um relat\u00f3rio dos passos utilizados. (Coloque em uma se\u00e7\u00e3o do material a ser entregue do roteiro - MkDocs!!!!!!!)</li> </ol> <p>Primeiramente, para levantar duas inst\u00e2ncias com a API do FastAPI, foi necess\u00e1rio criar uma rede virtual no OpenStack. Em seguida, foram criadas duas inst\u00e2ncias de m\u00e1quinas virtuais (VMs) com o Ubuntu Server 22.04, que serviram como servidores para a aplica\u00e7\u00e3o FastAPI. Essas VMs foram conectadas \u00e0 rede virtual criada anteriormente. Publicamos uma imagem do FastAPI no Docker Hub, e depois, instalamos o Docker nas VMs. Com o Docker instalado, baixamos a imagem do FastAPI e executamos os containers.</p> <p>Para o banco de dados, utilizamos o PostgreSQL, que foi instalado em uma das VMs. Configuramos o banco de dados para aceitar conex\u00f5es da rede virtual e criamos as tabelas necess\u00e1rias para a aplica\u00e7\u00e3o.</p> <p>Por fim, configuramos um balanceador de carga (Nginx) para distribuir as requisi\u00e7\u00f5es entre as duas inst\u00e2ncias do FastAPI. O Nginx foi instalado em uma VM separada, que tamb\u00e9m estava conectada \u00e0 rede virtual. Essa VM atuou como um ponto de entrada para as requisi\u00e7\u00f5es, encaminhando-as para as inst\u00e2ncias do FastAPI.</p> <ol> <li> <p>Anexe fotos e/ou diagramas contendo: arquitetura de rede da sua infraestrutura dentro do Dashboard do Openstack </p> </li> <li> <p>Lista de VMs utilizadas com nome e IPs alocados </p> </li> </ol> <p>Dashboard do FastAPI </p> <ol> <li>Prints, cada um demonstrando em qual server (m\u00e1quina f\u00edsica) cada inst\u00e2ncia foi alocada pelo OpenStack.</li> </ol> <p>Nginx </p> <p>FastAPI 1 </p> <p>FastAPI 2 </p> <p>PostgreSQL </p>"},{"location":"roteiro4/main/","title":"Relat\u00f3rio Roteiro 3 de Computa\u00e7\u00e3o em Nuvem","text":"<p>Autores: Lucas Novais, Mariana Albuquerque</p>"},{"location":"roteiro4/main/#1-objetivo","title":"1. Objetivo","text":""}]}